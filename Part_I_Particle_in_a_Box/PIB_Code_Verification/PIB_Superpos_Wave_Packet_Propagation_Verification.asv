% ============================================================================================================================
%%%%%%%%%% Preamble %%%%%%%%%%
% ============================================================================================================================

% Part I - Particle in a Box Wave Packet Simulation
% Superposition of particle in a box eigenstates modulated by a Gaussian
% Verification of the time propagation of Gaussian wave packets using the Crank-Nicolson method

% Author: Max L Butterworth
% MSc in Theoretical and Computational Chemistry Project
% University of Oxford

% ============================================================================================================================
%%%%%%%%%% Define constants and variables %%%%%%%%%%
% ============================================================================================================================

% Natural units have been adopted throughout
L = 1;% Length of the 1D box
m = 1; % Mass
h = 1; % Planck's constant in J s
hbar = 1; % Definition of h bar

N_steps = 1000; % Number of discretisation points

basis_funcs_indices = [1, 2]; % Create an array of the indices of PIB_eigenstates_norm that form the superposition
basis_funcs_coeffs = rand(1, length(basis_funcs_indices)); % Weightings of PIB eigenstates in the superposition
N_PIB_eigenfuncs = max(basis_funcs_indices); % The number of basis functions in the wave packet superposition

travelling_wavepacket = false; % Set whether the wavepacket should have the exp(1i * k * x) factor applied
k = (50 * pi)/L; % Set the wavenumber if travelling_wavepacket is set to true

% ============================================================================================================================
%%%%%%%%%% Discretise the spatial domain, x, and time domain, t %%%%%%%%%%
% ============================================================================================================================

x = linspace(0, L, N_steps); % Define the domain of the infinite potential well
dx = x(2) - x(1); % Calculate the spatial step size

dt = 1e-2; % Define the time step size
N_t = 1000; % Define the number of time steps to simulate

% ============================================================================================================================
%%%%%%%%%% Solve the Schrödinger equation using the finite difference method %%%%%%%%%%
% ============================================================================================================================

% Construct the Hamiltonian inside the infinite potential well
laplacian = (1/dx^2) * spdiags([1, -2, 1], -1:1, N_steps, N_steps); % Define the Laplacian operator
H = -((hbar^2)/(2*m)) * laplacian; % Define the Hamiltonian operator

% Find the eigenvalues and eigenvectors of the Hamiltonian matrix
[PIB_eigenstates, E_PIB] = eigs(H, N_PIB_eigenfuncs, 'smallestabs');

PIB_eigenstates_norm = zeros(N_steps, N_PIB_eigenfuncs); % Set up an array to store normalised PIB eigenfunctions

% Normalise eigenvectors
for i = 1:N_PIB_eigenfuncs
    PIB_eigenstates_norm(:, i) = PIB_eigenstates(:, i)/sqrt(trapz(x, abs(PIB_eigenstates(:, i)).^2));
end

% ============================================================================================================================
%%%%%%%%%% Generate an initial wave packet composed of a superposition of PIB eigenfunctions modulated by a Gaussian %%%%%%%%%%
% ============================================================================================================================

x0 = L/2; % Start evolving the wave packet from the centre of the box at t = 0
sigma = L/20; % Set the initial width of the wave packet

psi0 = zeros(N_steps, 1); % Initialise an empty array to store the initial wave packet

% Generate the superposition of PIB basis functions
for j = 1:length(basis_funcs_indices)
    psi0 = psi0 + (basis_funcs_coeffs(j) * PIB_eigenstates_norm(:, basis_funcs_indices(j)));
end

% Determine whether a travelling modulated Gaussian is required or not
if travelling_wavepacket == true % Travelling Gaussian required
    psi0 = exp(-(x - x0).^2/(2 * sigma^2)) .* exp(-1i * k * x) .* psi0; % Modulate the superposition by a travelling Gaussian

else % Travelling Gaussian not required
    psi0 = exp(-(x - x0).^2/(2 * sigma^2)) .* psi0; % Modulate the superposition by a Gaussian

end
plot(x, psi0)
psi0_norm = psi0/sqrt(trapz(x, abs(psi0).^2)); % Normalise the initial Gaussian wave packet

% ============================================================================================================================
%%%%%%%%%% Impose boundary conditions %%%%%%%%%%
% ============================================================================================================================

% Set the wavefunction to zero at the boundaries
psi0_norm(1) = 0;
psi0_norm(N_steps) = 0;
psi0_norm = sparse(psi0_norm); % Define the initial wavefunction as a sparse matrix to speed up the calculation

H = H(2:N_steps-1, 2:N_steps-1); % Impose boundary conditions: psi(0) = psi(L) = 0
H = sparse(H); % Define the Hamiltonian as a sparse matrix to speed up the calcualtion

x_internal = x(2:N_steps - 1); % Truncate the x array to account for boundary conditions

% ============================================================================================================================
%%%%%%%%%% Implement the Crank-Nicolson method to evolve the wavefunction and calculate probability current %%%%%%%%%%
% ============================================================================================================================

J_numerical = zeros(N_steps, N_t); % Initialise an array to store probability currents
first_deriv = spdiags([-1, 1], 0:1, N_steps-2, N_steps-2)/dx; % Define a first derivative operator using the finite difference method

psi_numerical = psi0_norm(2:N_steps-1); % Set the initial value of the wavefunction defined on the internal coordinates
psi_numerical_t = zeros(N_steps, N_t); % Initialise an array to store the wavefunction as it evolves in time
psi_numerical_t(2:N_steps-1, 1) = psi_numerical; % Store the initial wavefunction in the time evolution array

% Pre-compute matrices required for the Crank-Nicolson method
A = speye(N_steps-2) + (((1i * dt)/(2 * hbar)) * H);
B = speye(N_steps-2) - (((1i * dt)/(2 * hbar)) * H);

for t = 2:N_t % Loop over all time steps
    psi_numerical = A \ (B * psi_numerical); % Evolve the wavefunction defined on the internal coordinates over time
    psi_numerical = psi_numerical/sqrt(trapz(x_internal, abs(psi_numerical).^2)); % Normalise the time-evolved wavefunction
    psi_numerical_t(2:N_steps-1, t) = psi_numerical; % Store the time-evolved wavefunction in the time evolution array

    % Calculate probability current at each point along x
    J_numerical(2:N_steps - 1, t) = -((1i * hbar)/(2 * m)) * ((conj(psi_numerical) .* (first_deriv * psi_numerical)) - ((first_deriv * conj(psi_numerical)) .* psi_numerical));
end

% ============================================================================================================================
%%%%%%%%%% Compute the analytical time-evolved wave packet %%%%%%%%%%
% ============================================================================================================================

% Generate the analytical solutions to the Schrödinger equation for the PIB
PIB_superpos_analytical = zeros(length(x), 1); % Define an array to store the the superposition of analytical PIB eigenstates

% Create an array of a superposition of analytical PIB eigenfunctions defined by basis_funcs_coeffs and basis_funcs_indices
for l = 1:length(basis_funcs_indices)
    PIB_superpos_analytical = PIB_superpos_analytical + (basis_funcs_coeffs(l) * sqrt(2/L) * sin((basis_funcs_indices(l) * pi * x)/L).');
end
plot(x, PIB_superpos_analytical)
% Normalise the superposition
PIB_superpos_analytical_norm = PIB_superpos_analytical/sqrt(trapz(x, abs(PIB_superpos_analytical).^2));

% Determine whether a travelling modulated Gaussian is required or not
if travelling_wavepacket == true % Travelling Gaussian required

    % Modulate the analytical superposition by a travelling Gaussian
    PIB_superpos_analytical_norm = exp(-(x - x0).^2/(2 * sigma^2)).' .* exp(-1i * k * x) .* PIB_superpos_analytical_norm;

else % Travelling Gaussian not required
    PIB_superpos_analytical_norm = exp(-(x - x0).^2/(2 * sigma^2)).' .* PIB_superpos_analytical_norm; % Modulate the superposition by a Gaussian

end

E_eigenfunc_analytical = 0; % Initialise the energy of the analytical superposition
plot(x, PIB_superpos_analytical_norm)
% Calculate the total energy of the analytical superposition
for q = 1:length(basis_funcs_indices)
    E_eigenfunc_analytical = E_eigenfunc_analytical + (basis_funcs_coeffs(q) * ((basis_funcs_indices(q)^2 * pi^2 * hbar^2)/(2 * m * L^2)));
end

psi_analytical = PIB_superpos_analytical_norm; % Set the initial wave packet
psi_analytical_t = zeros(N_steps, N_t); % Initialise an array to store the analytical wavefunction as it evolves in time
psi_analytical_t(:, 1) = psi_analytical; % Store the initial wave packet in the time evolution array

% Propagate the analytical wavefunction through time
for r = 2:N_t
    psi_analytical = psi_analytical * exp(-1i * E_eigenfunc_analytical * (r-1) * dt / hbar); % Evolve the analytical wavefunction in time
    psi_analytical_t(:, r) = psi_analytical; % Store the time-evolved wave packet in the time evolution array
end

% ============================================================================================================================
%%%%%%%%%% Plot the time evolution of the wave packet, probability density, and flux %%%%%%%%%%
% ============================================================================================================================

figure; % Generate a figure

subplot(2, 2, 1) % Top Left subfigure
real_wavefunction_numerical = plot(x, real(psi_numerical_t(:, 1))); % Plot the real numerical wavefunction
hold on
real_wavefunction_analytical = plot(x, real(psi_analytical_t(:, 1))); % Plot the real analytical wavefunction
hold off
xlabel('$x$', 'Interpreter', 'latex'); % Label the x-axis
ylabel('$\mathrm{Re}(\psi(x, t))$', 'Interpreter', 'latex'); % Label the y-axis
ylim([min(real(psi_numerical_t(:))) max(real(psi_numerical_t(:)))]); % Set the y-limits for convenience
title('Real Component of the Wavefunction') % Add a title
grid on; % Add a grid to the plot

subplot(2, 2, 2) % Top right subfigure
imag_wavefunction_numerical = plot(x, imag(psi_numerical_t(:, 1))); % Plot the imaginary numerical wavefunction
hold on
imag_wavefunction_analytical = plot(x, imag(psi_analytical_t(:, 1))); % Plot the imaginary analytical wavefunction
hold off
xlabel('$x$', 'Interpreter', 'latex'); % Label the x-axis
ylabel('$\mathrm{Im}(\psi(x, t))$', 'Interpreter', 'latex'); % Label the y-axis
ylim([min(imag(psi_numerical_t(:))) max(imag(psi_numerical_t(:)))]); % Set the y-limits for convenience
title('Imaginary Component of the Wavefunction') % Add a title
grid on; % Add a grid to the plot

subplot(2, 2, 3) % Bottom Right subfigure
prob_density_numerical = plot(x, abs(psi_numerical_t(:, 1)).^2); % Plot the initial numerical probability density
hold on
prob_density_analytical = plot(x, abs(psi_analytical_t(:, 1)).^2); % Plot the initial analytical probability density
hold off
xlabel('$x$', 'Interpreter', 'latex'); % Label the x-axis
ylabel('$|\psi(x, t)|^2$', 'Interpreter', 'latex'); % Label the y-axis
ylim([min(abs(psi_numerical_t(:)).^2) max(real(abs(psi_numerical_t(:)).^2))]); % Set the y-limits for convenience
title('Probability Density') % Add a title
grid on; % Add a grid to the plot

subplot(2, 2, 4) % Bottom left subfigure
flux_plot = plot(x, J_numerical(:, 1)); % Plot the initial numerical probability density
xlabel('$x$', 'Interpreter', 'latex'); % Label the x-axis
ylabel('$J(x, t)$', 'Interpreter', 'latex'); % Label the y-axis
ylim([min(J_numerical(:)) max(J_numerical(:))]); % Set the y-limits for convenience
title('Probability Current') % Add a title
grid on; % Add a grid to the plot

% Animate the figures
for n = 1:N_t % Loop over all timesteps
    set(real_wavefunction_numerical, 'YData', real(psi_numerical_t(:, n))) % Update the real part of the numerical wavefunction
    set(real_wavefunction_analytical, 'YData', real(psi_analytical_t(:, n))) % Update the real part of the analytical wavefunction
    set(imag_wavefunction_numerical, 'YData', imag(psi_numerical_t(:, n))) % Update the imaginary part of the numerical wavefunction
    set(imag_wavefunction_analytical, 'YData', imag(psi_analytical_t(:, n))) % Update the imaginary part of the analytical wavefunction
    set(prob_density_numerical, 'YData', abs(psi_numerical_t(:, n)).^2); % Update the numerical probability density
    set(prob_density_analytical, 'YData', abs(psi_analytical_t(:, n)).^2); % Update the analyticalprobability density
    set(flux_plot, 'YData', J_numerical(:, n)); % Update the numerical flux plot
    pause(0.05); % Pause to create an animation
    drawnow; % Update the figures and display immediately
end